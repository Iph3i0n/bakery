<meta name="u-fetch">
  Fetches data from a URL and adds them to the context.
  <attr name="url">
    The main URL to use. May include parameters like `{locale}`
    to customise the URL for the user.
  </attr>
  <attr name="name">
    The name given to the result in the context.
  </attr>
  <attr name="fallback">
    The fallback URL for if the fetch fails. Useful for when fetching
    locale specific data from a CMS.
  </attr>
  <attr name="no-cache" type="boolean">
    By default all data is cached on the users machine. If set then
    that cache is disabled. Only use if you have to.
  </attr>
  <import use="Provider" from="../data.ts" />
  <import use="PaginationEvent" from="../pagination.ts" default />
  <base use="Receiver" from="../data.ts" />
</meta>

<script>
  let skip = 0;
  let take = 50;
  self.fetcher_override = "routing_data";

  function Language() {
    if (navigator.languages != undefined) return navigator.languages[0];
    return navigator.language;
  }

  const provider = new Provider(self, self.props.name);

  const options = () => {
    const existing = self.data;

    const params = existing ? existing.params : {};
    return ({
      locale: () => Language(),
      skip: () => skip,
      take: () => take,
      ...Object.keys(params).reduce((c, n) => ({ ...c, ["params." + n]: () => params[n] }), {})
    })
  };

  function process_url(url) {
    let result = url;
    const opts = options();
    for (const key in opts) url = url.replaceAll(`{${key}}`, opts[key]());

    return url;
  }

  const DATA_KEY = () => "__BAKERY_DATA__" + process_url(self.props.url);

  self.addEventListener(PaginationEvent.Key, (e) => {
    skip = e.Skip;
    take = e.Take;
    get_data();
  });

  const is_visible = () => {
    let current = self.parentElement;
    while (current && current.tagName !== "body") {
      if (current.tagName === "U-ROUTE") return !!self.data;
      current = current.parentElement;
    }

    return true;
  }

  let existing_route = window.location.pathname;

  const rendered_url = () => {
    if (!is_visible()) return undefined;

    return process_url(self.props.url);
  }

  self.addEventListener(RenderEvent.Key, async () => {
    const next = rendered_url();
    if (!next || next === existing_route) return;
    existing_route = next;

    if (!self.props["no-cache"]) {
      const cached = window.localStorage.getItem(DATA_KEY());
      if (cached) provider.data = JSON.parse(cached);
    }

    const r = await fetch(next);
    let final;

    if (!r.ok)
      if (self.props.fallback) {
        console.error(r);
        const res = await fetch(process_url(self.props.fallback));

        if (!res.ok) throw res;

        final = await res.json();
      } else throw r;
    else final = await r.json();

    provider.data = final;
    if (!self.props["no-cache"])
      window.localStorage.setItem(DATA_KEY(), JSON.stringify(final));
  });

  const handler = () => {
    self.dispatchEvent(new ShouldRender());
  }

  document.addEventListener("navigation-event", handler);
  self.addEventListener("popstate", handler);
</script>

<slot></slot>
