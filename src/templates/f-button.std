<meta name="f-button">
  A simple button that the user can click for various actions.
  If the `type` is included then the button can be a standard
  or submit button. If the `href` is included the the button
  is a link. Buttons that are placed next to other buttons
  will automatically merge into a group.

  <attr name="colour" type="colour" default="primary">
    The colour for the button to render.
  </attr>
  <attr name="type" type="button_type" optional>
    The button type when used as a standard button.
    Should not be included with `href` for consistent behavior.
  </attr>
  <attr name="href" optional>
    The URL to send the user to if the button is being used as
    a link. Should not be included with `type`.
  </attr>
  <attr name="target" type="target" optional>
    The standard target from an anchor element.
    Should only be included if `href` is present.
  </attr>
  <attr name="private" type="boolean">
    If set then the link will be treated as external.
    This means that `rel="noreferrer noopener"` will be applied.
  </attr>
  <attr name="spa" type="boolean">
    If set then the link will use a SPA push to navigate rather
    than loading the page. Will be ignored if `target` or
    `private` are set.
  </attr>
  <attr name="replace" type="boolean">
    Only used if `spa` is set. Will make the link replace the state
    rather than push. Useful if you don't want the back button to
    keep people on the page.
  </attr>
  <aria role="button" />
  <import use="FindForm" from="../form-element.ts" />
  <base use="UrlBuilder" from="../router.ts" />
  <import use="Router" from="../router.ts" default />
</meta>

<script>
  self.tabIndex = 0;

  function activate() {
    if (self.props.type === "button") return;
    else if (self.props.type === "submit") {
      const form = FindForm(self);
      if (!form) throw new Error("Cannot use a submit outside of a form");
      form.Submit();
    } else if (self.props.href) {
      const url = this.Render(self.props.href);
      if (self.props.target)
        window.open(
          url,
          self.props.target,
          self.props.private ? "noreferrer" : undefined
        );
      else if (self.props.spa)
        if (self.props.replace) Router.Replace(url);
        else Router.Push(url);
      else window.location.href = url;
    }
  }

  self.addEventListener(LoadedEvent.Key, () => {
    self.addEventListener("click", activate);

    self.addEventListener("keyup", e => {
      if (e.key !== "Enter") return;
      e.preventDefault();
      self.dispatchEvent(new MouseEvent("click", { bubbles: true }));
      activate();
    });

    const observer = new MutationObserver(() => {
      if (!self) {
        observer.disconnect();
        return;
      }

      self.dispatchEvent(new ShouldRender());
    });

    observer.observe(self.parentElement, { childList: true });
  });

  const is_last_button = () => {
    const next = self.nextSibling;
    if (next instanceof Text && next.wholeText.trim()) return false;
    return self.nextElementSibling?.tagName !== "F-BUTTON";
  };
  const is_first_button = () => {
    const next = self.previousSibling;
    if (next instanceof Text && next.wholeText.trim()) return false;
    return self.previousElementSibling?.tagName !== "F-BUTTON";
  };

  self.addEventListener(RenderEvent.Key, () => {
    if (is_last_button()) return;
    while (self.nextSibling instanceof Text) {
      self.nextSibling.remove();
    }
  });
</script>

<style>
  @js const theme = require("../theme.ts");
  @js const c = self.props.colour ?? 'primary';
  :host {
    position: relative;
    display: inline-flex;
    align-items: center;
    gap: 0.5em;
    theme.colour(c);
    theme.padding("small_block");
    theme.border("body");
    theme.text("body", "no-margin");
    -webkit-user-select: none;
    user-select: none;
    cursor: pointer;
    text-align: center;
    box-shadow: none;
    theme.transition("fast", "background-color", "border-color", "box-shadow");
  }

  :host(:hover),
  :host(:focus) {
    outline: none;
    theme.colour(c, 1.1);
    theme.border("body", "contrast");
    theme.shadow("small");
  }

  @if !is_last_button() {
    :host {
      border-right: none !important;
      border-top-right-radius: 0 !important;
      border-bottom-right-radius: 0 !important;
      box-shadow: none !important;
    }
  }

  @if !is_first_button() {
    :host {
      border-left: none !important;
      border-top-left-radius: 0 !important;
      border-bottom-left-radius: 0 !important;
      box-shadow: none !important;
    }
  }
</style>

<slot></slot>
