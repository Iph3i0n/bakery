<meta name="u-each">
  Repeats its children once for each item accessed from the context.
  <attr name="subject">
    A JavaScript snippet to extract the array from the context.
  </attr>
  <attr name="name">
    The name to use in sub items to extract the item from the context.
  </attr>
  <prop name="data">Data to use instead of items from the use attribute.</prop>
  <base use="Receiver" from="../data.ts" />
  <import use="Provider" from="../data.ts" />
</meta>

<script>
  self.accessor = "subject";

  self.style.display = "none";
  const id = "c" + crypto.randomUUID();
  let subject;

  function insertAfter(newNode, existingNode) {
    existingNode.parentNode.insertBefore(newNode, existingNode.nextSibling);
  }

  setTimeout(() => {
    if (self.children.length !== 1)
      throw new Error("u-each may only have one child");
    subject = self.children[0].cloneNode(true);
    subject.setAttribute("data-each-id", id);
    self.dispatchEvent(new ShouldRender());
  });

  function debounce(func, timeout = 50) {
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        func.apply(this, args);
      }, timeout);
    };
  }

  const rendered = debounce(() => {
    if (!subject) return;
    const data = self.data ?? [];

    const existing = self.parentElement.querySelectorAll(
      `[data-each-id="${id}"]`
    );

    let previous = self;
    let i = 0;
    for (i ; i < existing.length ; i++) {
      if (data[i]) existing[i].provider.data = d;
      else existing[i].remove();
      previous = existing[i];
    }

    for (i ; i < data.length ; i++) {
      const input = subject.cloneNode(true);
      insertAfter(input, previous);
      previous = input;
      input.provider = new Provider(input, self.props.name);
      input.provider.data = data[i];
    }
  });

  self.addEventListener(RenderEvent.Key, rendered);
</script>
