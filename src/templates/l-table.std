<meta name="l-table">
  A data table to display tabular data to the user.
  Intentionally limited. Only intended to be used for
  actual data. If you require interaction then consider
  using a solution with list groups or cards.
  Should only contain `l-table-row` and `l-table-cell` tags.
  <slot>The body of the schema</slot>
  <slot name="head">The head of the schema</slot>
  <attr name="use">
    A JavaScript snippet to get the data from the
    `u-` namespace.
  </attr>
  <prop name="data">Data to use instead of items from the use attribute.</prop>
  <base use="ContextFetcher" from="../base-classes/context-fetcher.ts" default />
</meta>

<script>
  let body_schema = [];
  let head_schema = [];

  function on_body(e) {
    body_schema = [];
    /** @type {Array<HTMLElement>} */
    const data = e.currentTarget.assignedElements();
    for (const child of data) {
      const input_row = [];
      for (const item of child.children) {
        input_row.push({
          use: new Function("row", "return " + item.getAttribute("use")),
          width: item.getAttribute("width"),
          height: item.getAttribute("height"),
          colspan: item.getAttribute("colspan"),
          rowspan: item.getAttribute("rowspan"),
        });
      }

      body_schema.push({
        content: input_row,
      });
    }
  }

  function on_head(e) {
    head_schema = [];
    /** @type {Array<HTMLElement>} */
    const data = e.currentTarget.assignedElements();
    for (const child of data) {
      const input_row = [];
      for (const item of child.children) {
        input_row.push({
          text: item.textContent,
          width: item.getAttribute("width"),
          height: item.getAttribute("height"),
          colspan: item.getAttribute("colspan"),
          rowspan: item.getAttribute("rowspan"),
        });
      }

      head_schema.push({
        content: input_row,
      });
    }
  }
</script>

<style>
  @js const theme = require("../theme.ts");

  :host {
    display: block;
    theme.border("body");
    theme.colour("surface");
    theme.shadow("body");
    overflow: hidden;
  }

  table {
    border-collapse: collapse;
    width: 100%;
  }

  thead tr {
    theme.border("body", "contrast", "bottom");
    theme.colour("body");
  }

  tbody tr:not(:last-child) {
    theme.border("small", undefined, "bottom");
  }

  tbody tr:nth-child(even) {
    theme.colour("surface", 0.95);
  }

  th {
    text-align: left;
    theme.text("body_large");
    theme.padding("small_block");
  }

  td {
    text-align: left;
    theme.text("body");
    theme.padding("small_block");
  }
</style>

<div style="display: none">
  <slot on:slotchange="on_body"></slot>
  <slot name="head" on:slotchange="on_head"></slot>
</div>

<table>
  <thead>
    <s:for subject=":head_schema" key="row">
      <tr>
        <s:for subject=":row.content" key="cell">
          <th
            width=":cell.width"
            height=":cell.height"
            colspan=":cell.colspan"
            rowspan=":cell.rowspan"
          >
            <s:text use=":cell.text"></s:text>
          </th>
        </s:for>
      </tr>
    </s:for>
  </thead>
  <tbody>
    <s:for subject=":self.use_string_context('use' ?? [])" key="row_data">
      <s:for subject=":body_schema" key="row">
        <tr>
          <s:for subject=":row.content" key="cell">
            <td
              width=":cell.width"
              height=":cell.height"
              colspan=":cell.colspan"
              rowspan=":cell.rowspan"
            >
              <s:text use=":cell.use(row_data)"></s:text>
            </td>
          </s:for>
        </tr>
      </s:for>
    </s:for>
  </tbody>
</table>
